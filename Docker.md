# What is docker?

Docker is a program that carves up a Linux computer into sealed containers that
run your code. Each has its own programs and file systems. All are isolated 
from anything else.

Docker containers are portable. They can be shipped from one place to another.
Focker also builds these containers for you. It is a kind of social platform 
that you can share your containers with others and use others' containers.

Docker is NOT a virtual machine. There is only one operating system underneath.
That operating system is carved up into little isolated spaces. These spaces 
are called containers, a self-contained sealed unit of software. It contains
everything needed to run that code. It has

* code
* configs
* processes in the containers
* networking that is only necessary to talk to other containers
* dependencies
* operating system(just enough to run the container)

It takes all the services that make up a Linux server(networking, storage, code,
interprocess communication) and makes a copy of that in the Linux kernel. Each
container has its own little world that it can not see out of and other 
containers can' t see in.

For example; you might have Red Hat Linux container running database, Ubuntu 
container hosting web server and a SUSE Linux container that has caching 
server. All of them communicate via virtual network. It does not matter what 
version  of Linux containers runs on, it just has to be Linux. Docker manages
all of this, monitor and tears it down when they are not needed.

About Docker;

* A client program named Docker, it is a command you type at terminal
* A server program that manages Linux system
* Has a program that builds containers from the code
* A service that distributes containers

Docker's main job is to manage a Linux server and start containers on it. If
you are on a Windows or Mac, you can use Linux virtual machine installed on 
your computer to use Docker on top of it.

# Images to Containers

A Docker image is every file that makes up just enough of operating systemto do
what you need to do. Unlike virtual machines, you can reduce operating system
to a minimal set of functionailities just enough to do what you gonna do. It is
efficient.

To see docker images on your computer, type ``docker images`` on terminal. 
Example output is below;

```
REPOSITORY       TAG              IMAGE ID            CREATED             SIZE
debian           latest           874e27b628fd        2 weeks ago         100MB
hello-world      latest           05a3bd381fc2        6 weeks ago         1.84kB
```
* Repository: Where the image came from
* Tag: Tag is a version number.
* Image Id: Given by Docker, internal representation.

You can refer to an image by its repository-tag combo or image id.

``docker run`` command takes an image and turns it into a running container.
```
docker run -ti debian:latest bash
#ti : Stands for terminal interactive
```

To exit, type **exit** or ctrl-d.
To see running docker images, type ``docker ps``.
```
ID	50bc9ae1f5cd
IMAGE	debian:latest
COMMAND	"bash"
CREATED	3 minutes ago
STATUS	Up 3 minutes
PORTS	
NAMES	pedantic_joliot
```

Container IDs and image IDs are different.
When you change the container, you do not change the originating image. For 
example; if you create a file or change some environment variable in a 
container, next time you run a container from the same image, you won' t see
the changes you made in first container.

# Containers to Images

When you create multiple containers from the same image, you get the same thing
all the times. This is the point of images, they are fixed save points that you
know everything is good.

When we exit a container, it enters into stopped *container state*.Wwe can see 
all containers currently running or exited ones with a modificaton to 
**docker ps** command.

```
docker ps -a
```
Command above will list all of the containers. Then we can use the information
to create an image of one of the earlier exited containers. Example will use the
container above.

```
docker commit pedantic_joliot my_image_2
```
*pedantic_joliot* here is a human readable name generated by Docker to ease 
referring containers. *my_image_2* is given by user to new image. If we run
this new image as a container, we can see whatever changes we made to that
*pedantic_joliot* container(original one)

# Running Processes in Containers

Docker containers have a main process in their name which we give with run 
command as argument;

``docker run <image_name> <process_name>``:  

Whenever the main process stops, Docker container that owns the process stops 
too. Docker containers also have Docker generated human-readable name.

* ``docker --rm ubuntu sleep 5``: Main process is *sleep*. Container lives for 
the duration of this sleep command and when process exits, container exits too.
Then, thanks to --rm option, your container is deleted. ``--rm`` option is
used when we need a container to run a specific thing but do not need it later.
* ``docker run bash -c "sleep 3; echo all done"``: In this format, you can give
multiple commands to container.
* ``docker run -d -ti ubuntu bash``: It starts the container and detaches it.
Container runs in the background. This command returns SHA-256 identifier of 
that container, but you can also use ``docker ps`` command to see far simpler
name of it.
* ``docker attach quirky_pasteur``: Reattaches to the detached container.
* ctrl q: This key combination detaches from the container.
* ``docker exec quirky_pasteur bash``: Starts another process in an existing 
container. Can not add ports, volumes etc. This process is a secondary process,
if it exits, container continues to run.

# Manage Containers

You can name docker containers easily by;
```
docker run --name example ubuntu bash
```

``docker logs <container_name>``: Keeps the outputs of the containers until
containers are removed. You can use logs to diagnose if there is a problem but
be careful: if your commands write too many output to terminal, it can make
the docker non-responsive if the output is huge. So you better save your output
in the files.

You can kill a running container, it gets into stopped state. Then you can 
remove the container. Stopped containers exist, you need to remove them 
explicitly.
```
docker kill <container_name>
docker rm <container_name>
```
When you remove a container, it is gone for good. You won' t see it in the 
output of ``docker ps`` command anymore.

You can enforce limits on how much resource containers will use.
```
docker run --memory 256[b,k,m,g] 
docker run --cpu-shares <relative_to_others>
docker run --cpu-quota <hard_limit>
```
Some good practices are;
* Do not configure containers to fetch their dependencies after they start to
run. That dependency might be removed from the repository in future. Use 
containers as they are meant to be, pack dependencies into the images.
* Give good names to important containers. This way you won' t think they are
not needed when you clean up some of your containers.

# Network Between Containers



